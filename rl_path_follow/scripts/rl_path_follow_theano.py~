#!/usr/bin/env python

import os, time

import rospy, rospkg

import numpy as np
from math import *
import cv2

from cv_bridge import CvBridge, CvBridgeError

import theano
import theano.tensor as T

import lasagne
from lasagne.updates import nesterov_momentum

from sensor_msgs.msg import Image
from geometry_msgs.msg import Twist

import scipy.io as io

class PathFollow:
    def __init__(self,
                 load_model    = False,
                 record_data   = False,
                 is_training   = False,
                 padding       = 'SAME',
                 n_filter_1    = 8,
                 filter_size_1 = 12,
                 pool_size_1   = 2,
                 n_filter_2    = 16,
                 filter_size_2 = 8,
                 pool_size_2   = 2,
                 n_filter_3    = 32,
                 filter_size_3 = 4,
                 pool_size_3   = 2,
                 n_hidden_1    = 128,
                 n_hidden_2    = 64,
                 max_lin_vel   = 0.5,
                 max_ang_vel   = 0.8,
                 min_lin_vel   = 0.15):

        self.pkg_path = rospkg.RosPack().get_path('rl_path_follow')

        def floatX(X):
            return np.asarray(X, dtype=theano.config.floatX)

        self.nu = 0.0                                                                               # linear (forward) velocity.
        self.om = 0.0                                                                               # angular (turn) velocity.
        self.y  = 0.0                                                                               # proportional to inverse curvature.

        self.input_image = np.zeros((1,60,80,1))                                                    # initial image (zeros).

        self.max_lin_vel = max_lin_vel                                                              # maximum and minimum velocites used for curvature and preprocessing and output.
        self.min_lin_vel = min_lin_vel
        self.max_ang_vel = max_ang_vel                                                              # taken from the teleop script.

        self.bridge = CvBridge()

        rospy.Subscriber('camera/rgb/image_rect_color', Image, self.rgb_cb)                         # subscibe to camera image as input. feeds into neural network. (INPUT)

        rospy.Subscriber('cmd_vel', Twist, self.cmd_cb)                                             # subscribe to command velocity. used for network to learn.

        self.transformed_image_pub = rospy.Publisher('network/transformed_ground_image', 
                                                                           Image, queue_size=5)     # publisher to show transformed (birds eye) ground image.

        self.display_image_pub = rospy.Publisher('network/display_ground_image',
                                                                           Image, queue_size=5)     # publisher to show image with used ground space.

        self.vel_pub = rospy.Publisher('network/cmd_vel', Twist, queue_size=5)                      # network output command.

        pts = [[[480,360],[640,480],[0,480],[160,360]],
               [[640,0],[640,480],[0,480],[0,0]]]                                                   # transoform for points onto ground plane

        self.d_pts = np.array(pts[0])

        self.M = cv2.getPerspectiveTransform(np.float32(pts[0]), np.float32(pts[1]))

        def init_weights(shape):
            return theano.shared(floatX(np.random.randn(*shape) * 0.01))

        if not record_data:
            def cnn_model(X, w_h1, w_h2, w_o):
                input_layer = X

                hidden_1    = T.nnet.relu(T.dot(input_layer, w_h1))

                hidden_2    = T.nnet.relu(T.dot(hidden_1, w_h2))

                output      = T.nnet.relu(T.dot(hidden_2, w_o))

                return output

            self.X = T.fmatrix()
            self.Y = T.fmatrix()


            if load_model:
                self.w_h1 = init_weights((4800, 800))
                self.w_h2 = init_weights((800, 200))
                self.w_o  = init_weights((200, 1))

            else:
                self.w_h1 = init_weights((4800, 800))
                self.w_h2 = init_weights((800, 200))
                self.w_o  = init_weights((200, 1))


            network_output = cnn_model(self.X, self.w_h1, self.w_h2, self.w_o)

            self.output    = theano.function(inputs=[self.X], 
                                             outputs=network_output, 
                                             allow_input_downcast=True)

        trX = np.random.randn(1,4800)

        print self.output(trX)


    def rgb_cb(self, image):
        try:
            cv_image = self.bridge.imgmsg_to_cv2(image)
        except CvBridgeError as e:
            print(e)

        self.input_image = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)                               # turn image to grayscale.
        self.input_image = cv2.warpPerspective(self.input_image,self.M,(640,480))                   # apply transformation to get approximate birds eye view.                      
        self.input_image = cv2.resize(self.input_image, (0,0), fx=0.125, fy=0.125)                  # compress image to a lower size.


        cv2.polylines(cv_image, [self.d_pts], 1, (255, 0, 0), thickness=5)                          # add outline of selected section for birds eye view.

        try:
            self.transformed_image_pub.publish(self.bridge.cv2_to_imgmsg(self.input_image))         # publish image for display and trouble shooting.
        except CvBridgeError as e:
            print(e)

        try:
            self.display_image_pub.publish(self.bridge.cv2_to_imgmsg(cv_image))                     # publish image for display and trouble shooting.
        except CvBridgeError as e:
            print(e)

        self.input_image = np.array(self.input_image).reshape(1,60,80,1) * (1.0 / 255)              # reshape and preprocess input image.

        self.feed_dict = {self.X: self.input_image}                                                 # pass the image to the neural network.


    def cmd_cb(self, cmd):
        self.nu = cmd.linear.x                                                                      # recorded linear velocity.
        self.om = cmd.angular.z                                                                     # recorded angular velocity.
        
        if self.nu > self.min_lin_vel:
            self.y = (self.om / self.nu)                                                            # path curvature. to be predicted by network. (OUTPUT)


    def set_velocity(self,
                     linear_velocity = 0.0):

        output_twist = Twist()

        network_output = 0.0

        output_twist.linear.x = linear_velocity
        output_twist.angular.z = network_output

        self.vel_pub.publish(output_twist)     


    def return_data(self):
        return (self.nu, self.om, self.y), self.input_image


    def train_model(self,
                    lr         = 0.00001,
                    n_epochs   = 1000,
                    batch_size = 128,
                    alpha      = 0.5):

        file_list = os.listdir(self.pkg_path + '/data/training_data')

        trX = []
        trY = []

        for f in file_list:
            data = io.loadmat(self.pkg_path + '/data/training_data/' + f + '/training_data.mat')
            trX = data['images']
            trY = data['velocities']

        trX = np.array(trX)
        trY = np.array(trY)[:,1].reshape(-1,1)

        print trX.shape
        print trY.shape

        l2 = T.sqr(self.output - self.Y)).mean()
        l1 = T.abs(self.output - self.Y)).mean()

        loss = alpha * l1 + (1.0 - alpha) * l2

        params = [self.w_h1, self.w_h2, self.w_o]

        updates = nesterov_momentum(loss, 
                                    params, 
                                    learning_rate=0.001,
                                    momentum=.9)

        for epoch in range(n_epochs):
            for start, end in zip(range(0, len(trX), batch_size), range(batch_size, len(trX), batch_size)):
                trX[start:end], trY[start:end]
            train_loss = trX, trY
            print('epoch: %d, loss: %f' % (epoch, train_loss))
        
        #TODO: save weights
